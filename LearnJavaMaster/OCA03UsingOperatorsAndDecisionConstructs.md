Chapter 3
Using Operators and Decision Constructs
THE OCA EXAM TOPICS COVERED IN THIS PRACTICE TEST INCLUDE
THE FOLLOWING:
Using Operators and Decision Constructs
Use Java operators; use parentheses to override operator precedence
Test equality between Strings and other objects using == and equals()
Create if and if/else and ternary constructs
Use a switch statement


1. Which of the following variable types is not permitted in a switch statement?
A. String
B. double
C. int
D. char

2. What is the value of tip after executing the following code snippet?
int meal = 5;
int tip = 2;
int total = meal + (meal>6 ? ++tip :
tip);
A. 1
B. 2
C. 3
D. 6

3. What is the output of the following application? 
package registration;
public class NameCheck {
public static void main(String... data) {
String john = "john";
String jon = new String(john);
System.out.print((john==jon)+" "+(john.equals(jon)));
}
}
A. true true
B. true false
C. false true
D. false false

4. What is the output of the following application?
package planning;
public class ThePlan {
public static void main(String[] input) {
int plan = 1;
plan = plan++ + --plan;
if(plan==1) {
System.out.print("Plan A");
} else { if(plan==2) System.out.print("Plan B");
} else System.out.print("Plan C");
}
}
A. Plan AB. Plan B
C. Plan C
D. None of the above

5. Which of the following statements about a default branch in a switch statement is correct?
A. All switch statements must include a default statement.
B. The default statement is required to be placed after all case statements.
C. Unlike a case statement, the default statement does not take a value.
D. A default statement can only be used when at least one case statement is present.

6. What is the value of thatNumber after the execution of the following code snippet?
long thatNumber = 5 >= 5 ? 1+2 : 1*1;
if(++thatNumber < 4)
thatNumber += 1;
A. 3
B. 4
C. 5
D. The answer cannot be determined until runtime.

7. Which statement immediately exits a switch statement, skipping all remaining case or
default branches?
A. exit
B. break
C. goto
D. continue

8. Which statement about ternary expressions is true?
A. In some cases, both expressions to the right of the conditional operator in a ternary
expression will be evaluated at runtime.
B. Ternary expressions require parentheses for proper evaluation.
C. The ternary expressions are a convenient replacement for an if-then-else
statement.
D. Ternary expressions support int and boolean expressions for the left-most operand.

9. What is the output of the following application?

package voting;
1: public class Election {
2: public void calculateResult(Integer candidateA, Integer candidateB) {
3: boolean process = candidateA == null || candidateA.intValue() < 10;
4: boolean value = candidateA && candidateB;
5: System.out.print(process || value);
6: }
7: public static void main(String[] unused) {
8: new Election().calculateResult(null,203);
9: }
10: }
A. true
B. false
C. The code does not compile.
D. The code compiles but throws a NullPointerException on line 3 at runtime.

10. What is the output of the following application?
package dinosaur;
public class Park {
public final static void main(String... arguments) {
int pterodactyl = 6;
long triceratops = 3;
if(pterodactyl % 3 >= 1)
triceratops++;
triceratops--;
System.out.print(triceratops);
}
}
A. 2
B. 3
C. 4
D. The code does not compile.

11. Which statement about if-then statements is true?
A. An if-then statement is required to have an else statement.
B. If the boolean test of an if-then statement evaluates to false , then the target clause
of the if-then statement will still be evaluated.
C. An if-then statement is required to cast an object.
D. An if-then statement can execute a single statement or a block {} .

12. What is the output of the following application?
package restaurant;
public class Pieces {
public static void main(String[] info) {
int flair = 15;if(flair >= 15 && flair < 37) {
System.out.print("Not enough");
} if(flair==37) {
System.out.print("Just right");
} else {
System.out.print("Too many");
}
}
}
A. Not enough
B. Just right
C. Too many
D. None of the above

13. Which statement about case statements of a switch statement is not true?
A. A case value can be final .
B. A case statement must be terminated with a break statement.
C. A case value can be a literal expression.
D. A case value must match the data type of the switch variable, or be able to be
promoted to that type.

14. Given the following truth table, which operator for the boolean expressions x and y
corresponds to this relationship?
x = true x = false
y = true
true
y = false false
false
false
A. --
B. ++
C. ||
D. &&

15. What is the output of the following code snippet?
int hops = 0;
int jumps = 0;
jumps = hops++;
if(jumps)
System.out.print("Jump!");
else
System.out.print("Hop!");
A. Jump!
B. Hop!C. The code does not compile.
D. The code compiles but throws an exception at runtime.

16. Fill in the blanks: The _____________ operator increases the value of a variable by
1 and returns the new value, while the _____________ operator decreases the
value of a variable by 1 and returns the original value.
A. pre-increment [ ++v ], pre-decrement [ --v ]
B. pre-increment [ ++v ], post-decrement [ v-- ]
C. post-increment [ v++ ], pre-decrement [ --v ]
D. post-increment [ v++ ], post-decrement [ v-- ]

17. What is the output of the following application?
package jungle;
public class TheBigRace {
public static void main(String[] in) {
int tiger = 2;
short lion = 3;
long winner = lion+2*(tiger + lion);
System.out.print(winner);
}
}
A. 11
B. 13
C. 25
D. None of the above

18. Given the following code snippet, assuming dayOfWeek is an int , what variable type of
saturday is not permitted?
final _________ saturday = 6;
switch(dayOfWeek) {
default:
System.out.print("Another Weekday");
break;
case saturday:
System.out.print("Weekend!");
}
A. byte
B. long
C. int
D. None of the above

19. Given the following code snippet, what is the value of dinner after it is executed?int time = 11;
int day = 4;
String dinner = time > 10 ? day ? "Takeout" : "Salad" : "Leftovers";
A. Takeout
B. Salad
C. The code does not compile but would compile if parentheses were added.
D. None of the above

20. What is the output of the following application?
package recreation;
public class Dancing {
public static void main(String[] vars) {
int leaders = 10 * (2 + (1 + 2 / 5);
int followers = leaders * 2;
System.out.print(leaders + followers < 10 ? "Too few" : "Too many");
}
}
A. Too few
B. Too many
C. The code does not compile.
D. The code compiles but throws a division by zero error at runtime.

21. What is the output of the following application?
package schedule;
public class PrintWeek {
public static final void main(String[] days) {
System.out.print(5 + 6 + "7" + 8 + 9);
}
}
A. 56789
B. 11789
C. 11717
D. The code does not compile.

22. Fill in the blanks: The______________ operator is used to find the difference
between two numbers, while the______________ operator is used to find the
remainder when one number is divided by another.
A. /, %
B. â€“, %
C. %, <23. What is the output of the following application?
package transporter;
public class Rematerialize {
public static void main(String[] input) {
int dog = 11;
int cat = 3;
int partA = dog / cat;
int partB = dog % cat;
int newDog = partB + partA * cat;
System.out.print(newDog);
}
}
A. 9
B. 11
C. 15
D. The code does not compile.

24. What is the output of the following application?
package dessert;
public class IceCream {
public final static void main(String... args) {
int flavors = 30;
int eaten = 0;
switch(flavors) {
case 30: eaten++;
case 40: eaten+=2;
default: eaten--;
}
System.out.print(eaten);
}
}
A. 1
B. 2
C. 3
D. The code does not compile.

25. What is the output of the following application?
package mode;
public class Transportation {
public static String travel(int distance) {
return distance<1000 ? "train" : 10;
}
public static void main(String[] answer) {
System.out.print(travel(500));
}}
A. train
B. 10
C. The code does not compile.
D. The code compiles but throws an exception at runtime.

26. Fill in the blanks: Given two non-null String objects with reference names
apples ______________ and oranges , if apples oranges evaluates to true , then
apples ______________ oranges must also evaluate to true .
A. == , equals()
B. != , equals()
C. equals() , ==
D. equals() , =!

27. For a given non-null String myTestVariable , what is the resulting value of executing
the statement myTestVariable.equals(null) ?
A. true
B. false
C. The statement does not compile.
D. The statement compiles but will produce an exception when used at runtime.

28. How many 1 s are outputted when the following application is compiled and run?
package city;
public class Road {
public static void main(String... in) {
int intersections = 100;
int streets = 200;
if (intersections < 150) {
System.out.print("1");
} else if (streets && intersections > 1000) {
System.out.print("2");
} if (streets < 500)
System.out.print("1");
else
System.out.print("2");
}
}
A. None
B. One
C. Two
D. The code does not compile.29. Which statement about the logical operators & and && is true?
A. The & and && operators are interchangeable, always producing the same results at
runtime.
B. The & operator always evaluates both operands, while the && operator may only
evaluate the left operand.
C. Both expressions evaluate to true if either operand is true .
D. The & operator always evaluates both operands, while the && operator may only
evaluate the right operand.

30. What is the output of the following code snippet?
int x = 10, y = 5;
boolean w = true, z = false;
x = w ? y++ : y--;
w = !z;
System.out.print((x+y)+" "+(w ? 5 : 10));
A. The code does not compile.
B. 10 10
C. 11 5
D. 12 5

31. What is the output of the following application?
package bob;
public class AreYouBob {
public static void main(String[] unused) {
String bob = new String("bob");
String notBob = bob;
System.out.print((bob==notBob)+" "+(bob.equals(notBob)));
}
}
A. true true
B. true false
C. false true
D. false false

32. What is the value of 12 + 6 * 3 % (1 + 1) in Java?
A. 0
B. 12
C. 14
D. None of the above

33. Given the following truth table, the boolean variables p and q , and the expression 
p ^ q , what are the missing values in the truth table, starting with the first column?

                           | p = true      | p = false
                q = true   | false         | true
                q = false  |               | 
A. false and true
B. false and false
C. true and true
D. true and false

34. Which of the following is not a possible result of executing the following application?
public class ConditionallyLogical {
    public static void main(String... data) {
        if(data.length>=1
            && (data[0].equals("sound") || data[0].equals ("logic"))
            && data.length<2) {
            System.out.print(data[0]);
        }
    }
}
A. Nothing is printed.
B. sound is printed.
C. The application throws an exception at runtime.
D. logic is printed.

35. Fill in the blanks: The operators + ,______________ ,______________
,______________ , and ++ are listed in the same or increasing level of operator
precedence.
A. * , -- , /
B. % , - , *
C. / , * , %
D. * , - , /

36. What statement about the ^ operator is correct?
A. If one of the operands of ^ is true , then the result is always true .
B. There is a conditional form of the operator, denoted as ^^ .
C. If both operands of ^ are true , the result is true .
D. The ^ operator can only be applied to boolean values.

37. Given the following Venn diagram and the variables, x , y , and z , which Java expression
most closely represents the filled-in region of the diagram?
A. x || z
B. y || (y && z)
C. x || y
D. y && x

38. What variable type of red allows the following application to compile?
package tornado;
public class Kansas {
public static void main(String[] args) {
int colorOfRainbow = 10;
________ red = 5;
switch(colorOfRainbow) {
default:
System.out.print("Home");
break;
case red:
System.out.print("Away");
}
}
}
A. long
B. double
C. int
D. None of the above

39. Which two operators would be used to test if a number is equal to or greater than 5.21
but strictly less than 8.1 ?
A. > and <=B. >= and >
C. < and >=
D. < and >

40. What is the output of the following application?
package transporter;
public class TurtleVsHare {
    public static void main(String[] arguments) {
        int turtle = 10 * (2 + (3 + 2) / 5);
        int hare = turtle < 5 ? 10 : 25;
        System.out.print(turtle < hare ? "Hare wins!" : "Turtle wins!");
    }
}
A. Hare wins!
B. Turtle wins!
C. The code does not compile.
D. The code compiles but throws a division by zero error at runtime.

41. What is the output of the following application?
public class CountEntries {
    public static int getResult(int threshold) {
        return threshold > 5 ? 1 : 0;
    }
    
    public static final void main(String[] days) {
        System.out.print(getResult(5)+getResult(1)
        +getResult(0)+getResult(2)+"");
    }
}

A. 0
B. 1
C. 0000
D. 1000

42. What is the output of the following application?
package yoyo;
public class TestGame {
public String runTest(boolean spinner, boolean roller) {
    if(spinner = roller) return "up";
            else return roller ? "down" : "middle";
    }
    public static final void main(String pieces[]) {
        final TestGame tester = new TestGame();
        System.out.println(tester.runTest(false,true));
    }
}

A. up
B. middle
C. down
D. The code does not compile.

43. Fill in the blanks: The______________ operator is true if either of the operands
are true , while the______________ operator flips a boolean value.
A. + , -
B. && , !
C. | , -
D. || , !

44. Given the following code snippet, what is the value of movieRating after it is executed?
int characters = 5;
int story = 3;
double movieRating = characters <= 4 ? 3 : story>1 ? 2 : 1;
A. 2.0
B. 3.0
C. The code does not compile but would compile if parentheses were added.
D. None of the above

45. Fill in the blanks: A switch statement can have______________ case statements
and______________ default statements.
A. at most one, at least one
B. any number of, at most one
C. at least one, any number of
D. at least one, at most one

46. Which of the following is not a possible result of executing the following application?
public class OutsideLogic {
public static void main(String... weather) {
System.out.print(weather[0]!=null
&& weather[0].equals("sunny")
&& !false
? "Go Outside" : "Stay Inside");
}
}
A. Nothing is printed.B. The application throws an exception at runtime.
C. Go Outside is printed.
D. Stay Inside is printed.

47. What is the value of (5 + (!2 + 8) * 3 - 3 % 2)/2 in Java?
A. 2
B. 11
C. 16
D. None of the above

48. Given the following truth table, the boolean variables w and z , and the expression w ||
z , what are the missing values in the truth table, starting with the first row?
w = true w = false
z = true
true
z = false
false
A. false and false
B. true and false
C. true and true
D. false and true

49. Fill in the blanks: The operators â€“ ,______________ ,______________
,______________ , and % are listed in the same or increasing level of operator
precedence.
A. + , / , *
B. -- , - , *
C. ++ , / , *
D. * , ++ , %

50. What is the output of the following application?
public class Baby {
    public static String play(int toy, int age) {
        final String game;
            if(toy<2)
                game = age > 1 ? 1 : 10; // p1
             else
                game = age > 3 ? "Ball" : "Swim"; // p2
        return game;
    }
    public static void main(String[] variables) {
        System.out.print(play(5,2));
    }
}
A. Ball
B. Swim
C. The code does not compile due to p1 . 
D. The code does not compile due to p2 .

Comments Question 50 : Nao  copila na linha P1 e nÃ£o pode mudar uma variavel do tipo final 


1. B. Uma instruÃ§Ã£o switch suporta os tipos primitivos byte, short, char e int e o
classes String, Character, Byte, Short e Inteiro. Ele tambÃ©m suporta enumerados
tipos. Tipos de ponto flutuante como float e double nÃ£o sÃ£o suportados, portanto, Option
B Ã© a resposta correta.

2. A. Lembre-se de que em expressÃµes ternÃ¡rias, apenas uma das duas expressÃµes mais Ã  direita
sÃ£o avaliados. Como a refeiÃ§Ã£o> 6 Ã© falsa, a dica â€“â€“ Ã© avaliada e a dica ++ Ã© ignorada. o
O resultado Ã© que a dica Ã© alterada de 2 para 1, tornando a opÃ§Ã£o A a resposta correta. o
o valor total Ã© 6, pois o operador de prÃ©-incremento foi usado na ponta, embora vocÃª
nÃ£o precisava saber disso para resolver a questÃ£o.

3. C. A primeira atribuiÃ§Ã£o cria um novo objeto String "john". A segunda linha explicitamente
usa a nova palavra-chave, o que significa que um novo objeto String Ã© criado. Como esses objetos sÃ£o
nÃ£o Ã© o mesmo, o teste == neles Ã© avaliado como falso. O teste equals () neles
retorna true porque os valores aos quais eles se referem sÃ£o equivalentes. Portanto, o correto
resposta Ã© C.

4. D. Este cÃ³digo nÃ£o Ã© compilado porque possui mais duas instruÃ§Ãµes como parte de um Ãºnico if-
entÃ£o declaraÃ§Ã£o. Observe que a segunda instruÃ§Ã£o if nÃ£o estÃ¡ conectada Ã  Ãºltima else
declaraÃ§Ã£o. Por esse motivo, a opÃ§Ã£o D, nenhuma das opÃ§Ãµes acima, Ã© a resposta correta.

5. C. Uma instruÃ§Ã£o padrÃ£o dentro de uma instruÃ§Ã£o switch Ã© opcional e pode ser colocada em qualquer
ordem dentro das declaraÃ§Ãµes de caso do comutador, tornando as OpÃ§Ãµes A e B incorretas. OpÃ§Ã£o
D Ã© uma instruÃ§Ã£o incorreta, pois uma instruÃ§Ã£o switch pode ser composta por um Ãºnico padrÃ£o
declaraÃ§Ã£o e nenhuma declaraÃ§Ã£o de caso. A opÃ§Ã£o C estÃ¡ correta porque uma instruÃ§Ã£o padrÃ£o
nÃ£o assume um valor, diferentemente de uma instruÃ§Ã£o de caso.

6. B. A atribuiÃ§Ã£o inicial desse NÃºmero segue a primeira ramificaÃ§Ã£o do ternÃ¡rio
expressÃ£o. Como 5> = 5 Ã© avaliado como verdadeiro, um valor de 3 Ã© atribuÃ­do a esseNÃºmero. Dentro
Na prÃ³xima linha, o operador de prÃ©-incremento incrementa o valor desseNÃºmero para 4 e
retorna um valor de 4 para a expressÃ£o. Como 4 <4 Ã© avaliado como falso, o bloco if-then
Ã© pulado. Isso deixa o valor desse nÃºmero como 4, tornando a opÃ§Ã£o B a correta
responda.

7. B. A instruÃ§Ã£o break sai de uma instruÃ§Ã£o switch, pulando todas as ramificaÃ§Ãµes restantes,
tornando a opÃ§Ã£o B a resposta correta. Na opÃ§Ã£o A, exit nÃ£o Ã© uma instruÃ§Ã£o em Java. Dentro
OpÃ§Ã£o C, goto Ã© uma palavra reservada, mas nÃ£o utilizada em Java. Finalmente, na opÃ§Ã£o D, continue Ã©
uma declaraÃ§Ã£o, mas usada apenas para loops.

8. C. A opÃ§Ã£o A estÃ¡ incorreta, pois apenas uma das duas expressÃµes Ã  direita Ã© avaliada em
tempo de execuÃ§Ã£o. Os parÃªnteses costumam ser Ãºteis para ler expressÃµes ternÃ¡rias, mas nÃ£o sÃ£o
necessÃ¡rio, tornando a opÃ§Ã£o B incorreta. A opÃ§Ã£o C Ã© uma afirmaÃ§Ã£o correta sobre ternÃ¡rio
operadores, pois sÃ£o comumente usados â€‹â€‹para substituir instruÃ§Ãµes curtas se-entÃ£o-outro. Finalmente,

9.A opÃ§Ã£o D estÃ¡ incorreta, pois apenas expressÃµes booleanas sÃ£o permitidas na extremidade esquerda
operando de uma expressÃ£o ternÃ¡ria. C. Na linha 4, candidato A e candidato B sÃ£o nÃºmeros, mas a operaÃ§Ã£o && sÃ³ pode ser
aplicado a expressÃµes booleanas. Portanto, o cÃ³digo nÃ£o Ã© compilado devido Ã  linha 4,
fazendo C a resposta correta. Todas as outras linhas estÃ£o corretas. Observe que se a linha 4 for
fixa, a linha 3 nÃ£o produz uma NullPointerException em tempo de execuÃ§Ã£o. O condicional ||
e a verificaÃ§Ã£o nula anterior permite que o cÃ³digo chame apenas intValue () se o candidatoA for
nÃ£o nulo .

10. A. O primeiro passo Ã© determinar se a expressÃ£o da instruÃ§Ã£o if-then Ã© ou nÃ£o
executado. A expressÃ£o 6% 3 Ã© avaliada como 0, pois nÃ£o hÃ¡ resto e como 0
> = 1 Ã© false, a expressÃ£o triceratops ++ nÃ£o Ã© chamada. Observe que nÃ£o hÃ¡ colchetes
{} na instruÃ§Ã£o if-then. Apesar de o tricerÃ¡topo ser recuado, nÃ£o Ã©
parte da instruÃ§Ã£o if-then. Lembre-se de que o Java nÃ£o usa recuo para determinar
o inÃ­cio ou o fim de uma declaraÃ§Ã£o. Portanto, o triceratops - Ã© sempre executado,
resultando em um valor 2 para triceratops e tornando a opÃ§Ã£o A a resposta correta.

11. D. A opÃ§Ã£o A estÃ¡ incorreta porque as instruÃ§Ãµes else sÃ£o totalmente opcionais. A opÃ§Ã£o B tambÃ©m Ã©
incorreta. O destino de uma instruÃ§Ã£o if-then nÃ£o Ã© avaliado se o teste booleano for
falso. A opÃ§Ã£o C estÃ¡ incorreta. Embora uma declaraÃ§Ã£o if-then seja freqÃ¼entemente usada para testar se
se um objeto Ã© de um tipo especÃ­fico para convertÃª-lo, nÃ£o Ã© necessÃ¡rio converter um objeto.
A opÃ§Ã£o D estÃ¡ correta, pois uma instruÃ§Ã£o if-then pode executar uma Ãºnica instruÃ§Ã£o ou um bloco
do cÃ³digo {}.

12. D. Para esta pergunta, ajuda notar que a segunda declaraÃ§Ã£o if-then nÃ£o Ã©
conectado Ã  primeira instruÃ§Ã£o if-then, pois nÃ£o hÃ¡ mais como se juntar a eles. Quando isso
cÃ³digo Ã© executado, a primeira instruÃ§Ã£o if-then gera NÃ£o Ã© suficiente, pois o estilo Ã©> = 15 e
<37 A segunda instruÃ§Ã£o if-then Ã© entÃ£o avaliada. Como o talento nÃ£o Ã© 37, o
expressÃ£o Demasiada Ã© emitida. Como duas instruÃ§Ãµes sÃ£o emitidas, opÃ§Ã£o D, nenhuma
acima, Ã© a resposta correta.

13. B. Um valor de caso deve ser uma expressÃ£o constante, como uma variÃ¡vel literal ou final, para que
As opÃ§Ãµes A e C sÃ£o declaraÃ§Ãµes verdadeiras sobre valores de caso. Uma declaraÃ§Ã£o de caso pode ser
finalizada por uma instruÃ§Ã£o break, mas nÃ£o Ã© necessÃ¡ria, tornando a OpÃ§Ã£o B a falsa
declaraÃ§Ã£o e resposta correta. A opÃ§Ã£o D tambÃ©m Ã© uma afirmaÃ§Ã£o verdadeira sobre valores de caso.

14. D. A questÃ£o Ã© sobre operadores booleanos. Como as opÃ§Ãµes A e B sÃ£o numÃ©ricas
operadores, eles podem ser desconsiderados instantaneamente. A questÃ£o entÃ£o simplifica para qual
expressÃ£o booleana, && ou || , corresponde Ã  tabela verdade que Ã© avaliada apenas como verdadeira
se ambos os operandos forem verdadeiros. Somente o operador lÃ³gico && conjuntivo representa isso
relacionamento, tornando a opÃ§Ã£o D a resposta correta.

15. C. O valor de saltos e saltos nÃ£o Ã© importante porque este cÃ³digo nÃ£o compila,
tornando a opÃ§Ã£o C a resposta correta. Ao contrÃ¡rio de outras linguagens de programaÃ§Ã£o, Java
nÃ£o converte automaticamente nÃºmeros inteiros em valores booleanos para uso em if-then
afirmaÃ§Ãµes. A declaraÃ§Ã£o if (jumps) Ã© avaliada como if (0) e, como 0 nÃ£o Ã© um booleano
valor, o cÃ³digo nÃ£o compila. Observe que o valor da variÃ¡vel jumps Ã© irrelevante
neste exemplo; nenhum inteiro Ã© avaliado como um valor booleano em Java.

16. B. Operadores de prefixo modificam a variÃ¡vel e avaliam para o novo valor, enquanto o postfix
operadores modificam a variÃ¡vel, mas retornam o valor original. Portanto, a opÃ§Ã£o B Ã© o
resposta correta.

17. B. Para este problema, ajuda a reconhecer que os parÃªnteses tÃªm precedÃªncia sobre os
operaÃ§Ãµes fora dos parÃªnteses. Depois de substituirmos as variÃ¡veis â€‹â€‹por valores, o
a expressÃ£o se torna: 3 + 2 * (2 + 3). Em seguida, calculamos o valor entre parÃªnteses para
obtenha 3 + 2 * 5. Como o operador de multiplicaÃ§Ã£o tem maior precedÃªncia que adiÃ§Ã£o, nÃ³s
avalie-o primeiro, resultando em 3 + 10 = 13, tornando a opÃ§Ã£o B a resposta correta.

18. B. Qualquer valor que possa ser implicitamente promovido para int funcionarÃ¡ para a declaraÃ§Ã£o de caso
com uma entrada int. Como as instruÃ§Ãµes switch nÃ£o suportam valores longos, e longas
nÃ£o pode ser convertido para int sem uma possÃ­vel perda de dados, a opÃ§Ã£o B Ã© a correta
responda.

19. D. Embora parÃªnteses sejam recomendados para operaÃ§Ãµes ternÃ¡rias, especialmente
uns, eles nÃ£o sÃ£o necessÃ¡rios; portanto, a opÃ§Ã£o C estÃ¡ incorreta. O cÃ³digo nÃ£o compila
porque day Ã© uma expressÃ£o int, nÃ£o booleana, na segunda operaÃ§Ã£o ternÃ¡ria,
tornando a opÃ§Ã£o D a resposta correta. Lembre-se de que em Java, os valores numÃ©ricos nÃ£o sÃ£o
aceito no lugar de expressÃµes booleanas em instruÃ§Ãµes if-then ou operaÃ§Ãµes ternÃ¡rias.

20. C. Embora o cÃ³digo envolva inÃºmeras operaÃ§Ãµes, nada disso importa para resolver esse problema.
problema. A chave para resolvÃª-lo Ã© perceber que a linha que designa os lÃ­deres
A variÃ¡vel tem um nÃºmero desigual de parÃªnteses. Sem parÃªnteses equilibrados, o
o cÃ³digo nÃ£o serÃ¡ compilado, tornando a opÃ§Ã£o C a resposta correta.

21. B. Lembre-se de que Java avalia + da esquerda para a direita. Os dois primeiros valores sÃ£o ambos
nÃºmeros, entÃ£o o + Ã© avaliado como adiÃ§Ã£o numÃ©rica, resultando em uma reduÃ§Ã£o para 11 +
"7" + 8 + 9. Os prÃ³ximos dois termos, 11 + "7", sÃ£o tratados como concatenaÃ§Ã£o de strings desde
um dos termos Ã© uma String. Isso nos permite reduzir a expressÃ£o para "117" + 8 + 9.
Da mesma forma, os dois termos finais sÃ£o avaliados, um de cada vez, com a String no
esquerda. Portanto, o valor final Ã© 11789, tornando a opÃ§Ã£o B a resposta correta.

22. B. O operador subtraÃ§Ã£o - Ã© usado para encontrar a diferenÃ§a entre dois nÃºmeros,
enquanto o operador% do mÃ³dulo Ã© usado para encontrar o restante quando um nÃºmero Ã©
dividido por outro, tornando a opÃ§Ã£o B a resposta correta. As outras opÃ§Ãµes usam
operadores que nÃ£o correspondem a essa descriÃ§Ã£o.

23. B. O cÃ³digo Ã© compilado sem problemas, tornando a OpÃ§Ã£o D incorreta. O foco disso
A questÃ£o estÃ¡ mostrando como a divisÃ£o e o mÃ³dulo de dois nÃºmeros podem ser usados â€‹â€‹para
reconstitua um dos operandos originais. Neste exemplo, parteA Ã© a divisÃ£o inteira
dos dois nÃºmeros. Como 3 nÃ£o divide 11 uniformemente, Ã© arredondado para 3. o
A variÃ¡vel partB Ã© o restante da primeira expressÃ£o, que Ã© 2. The newDog
A variÃ¡vel Ã© uma expressÃ£o que reconstitui o valor original do cÃ£o usando a divisÃ£o
valor e o restante. Observe que, devido Ã  precedÃªncia do operador, a multiplicaÃ§Ã£o *
A operaÃ§Ã£o Ã© avaliada antes da operaÃ§Ã£o de adiÃ§Ã£o +. O resultado Ã© o valor original
de 11 para o cÃ£o Ã© produzido por este programa. 


24. B. O cÃ³digo Ã© compilado sem problemas, portanto, a opÃ§Ã£o D estÃ¡ incorreta. No interruptor desta pergunta
declaraÃ§Ã£o, nÃ£o hÃ¡ declaraÃ§Ãµes de interrupÃ§Ã£o. Depois que a instruÃ§Ã£o de caso correspondente, 30, for
atingido, todas as instruÃ§Ãµes de caso restantes serÃ£o executadas. A variÃ¡vel consumida Ã©
aumentado em 1, depois 2 e, em seguida, reduzido em 1, resultando em um valor final de 2, tornando OpÃ§Ã£o
B a resposta correta.

25. C. As operaÃ§Ãµes ternÃ¡rias exigem que ambas as expressÃµes Ã  direita sejam de dados compatÃ­veis
tipos. Neste exemplo, a primeira expressÃ£o Ã  direita da operaÃ§Ã£o ternÃ¡ria externa Ã©
do tipo String, enquanto a segunda expressÃ£o Ã  direita Ã© do tipo int. Como esses dados
tipos sÃ£o incompatÃ­veis, o cÃ³digo nÃ£o Ã© compilado e a opÃ§Ã£o C Ã© a resposta correta.

26. A. Para esta pergunta, lembre-se de que, se dois objetos String forem avaliados como true usando ==,
entÃ£o eles sÃ£o o mesmo objeto. Se eles sÃ£o o mesmo objeto String, equals () serÃ¡
trivialmente retorne verdadeiro. A opÃ§Ã£o A reflete corretamente esse princÃ­pio. A opÃ§Ã£o B estÃ¡ incorreta, pois
dois objetos String que nÃ£o sÃ£o iguais ainda podem ser equivalentes em termos de igual a ().
Por exemplo, maÃ§Ã£s == nova String (maÃ§Ã£s) Ã© avaliada como falsa, mas igual a () serÃ¡
avalie como true nesses objetos String. Da mesma forma, as opÃ§Ãµes C e D tambÃ©m estÃ£o incorretas
porque dois objetos String que sÃ£o equivalentes em termos de equals () podem ser diferentes
objetos.

27. B. A instruÃ§Ã£o compila e executa sem problemas, tornando as OpÃ§Ãµes C e D incorretas.
Como somos informados de que myTestVariable nÃ£o Ã© nulo, a instruÃ§Ã£o sempre avaliarÃ¡
para false, tornando a opÃ§Ã£o B a resposta correta. Observe que, se myTestVariable for nulo,
o cÃ³digo ainda serÃ¡ compilado, mas lanÃ§arÃ¡ uma chamada NullPointerException igual a ()
em tempo de execuÃ§Ã£o.


28. D. O cÃ³digo nÃ£o Ã© compilado, tornando a OpÃ§Ã£o D a resposta correta. A razÃ£o pela qual
o cÃ³digo nÃ£o compila Ã© devido ao teste na segunda instruÃ§Ã£o if-then. o
expressÃ£o (ruas e cruzamentos> 1000) Ã© invÃ¡lida porque ruas nÃ£o Ã© uma
expressÃ£o booleana e nÃ£o pode ser usado como o lado esquerdo da lÃ³gica conjuntiva
operador&&. A linha de cÃ³digo foi projetada para se parecer com a expressÃ£o corrigida
(ruas> 1000 && cruzamentos> 1000. Observe que a expressÃ£o fixa requer dois
operadores relacionais. Se a segunda instruÃ§Ã£o if-then foi corrigida, o comando
o aplicativo compilaria e produziria dois 1s, tornando a opÃ§Ã£o C a resposta correta.

29. B. Os operadores & e && (AND) nÃ£o sÃ£o intercambiÃ¡veis, pois o operador conjuntivo &
sempre avalia os dois lados da expressÃ£o, enquanto o conjunto condicional &&
O operador avalia apenas o lado direito da expressÃ£o se o lado esquerdo estiver
determinado a ser verdade. Ã‰ por isso que operadores condicionais sÃ£o freqÃ¼entemente chamados de
operadores de circuito, pulando a expressÃ£o do lado direito em tempo de execuÃ§Ã£o. Para estes
motivos, a opÃ§Ã£o B Ã© a resposta correta. Observe que a opÃ§Ã£o C Ã© uma instruÃ§Ã£o incorreta
tambÃ©m, uma vez que descreve operadores disjuntivos (OR).

30. C. O cÃ³digo Ã© compilado, portanto a opÃ§Ã£o A estÃ¡ incorreta. Desde que w comeÃ§a verdadeiro, a terceira linha
pega o primeiro lado direito da expressÃ£o ternÃ¡ria retornando e atribuindo 5 para x
(operador pÃ³s-incremento) enquanto incrementa y para 6. Observe que o segundo lado direito
o lado da expressÃ£o ternÃ¡ria yâ€“â€“ nÃ£o Ã© avaliado, pois os operadores ternÃ¡rios avaliam apenas uma expressÃ£o da mÃ£o 
direita em tempo de execuÃ§Ã£o. Na quarta linha, o valor de w Ã© definido
para! z. Como z Ã© falso, o valor de w permanece verdadeiro. A linha final gera o valor de
(5 + 6) e (verdadeiro? 5: 10), que Ã© 11 5, tornando a opÃ§Ã£o C a resposta correta.

31. A. A primeira atribuiÃ§Ã£o realmente usa dois objetos String, o literal "bob" e o
String criada com a nova palavra-chave. Independentemente, apenas o segundo objeto Ã© atribuÃ­do a
a variÃ¡vel bob. A segunda variÃ¡vel, notBob, recebe uma referÃªncia ao valor de
a variÃ¡vel bob. Isso significa que nÃ£o apenas o teste equals () passa, mas eles sÃ£o
na verdade, o mesmo objeto, entÃ£o o teste == tambÃ©m Ã© verdadeiro. Portanto, a resposta correta Ã©
OpÃ§Ã£o A.

32. B. A questÃ£o Ã© sobre precedÃªncia do operador e ordem de operaÃ§Ã£o. o
operadores de multiplicaÃ§Ã£o * e% de mÃ³dulo tÃªm a maior precedÃªncia, embora o que
estÃ¡ dentro dos parÃªnteses precisa ser avaliado primeiro. Podemos reduzir a expressÃ£o para
o seguinte: 12 + 6 * 3% 2. Como multiplicaÃ§Ã£o * e% do mÃ³dulo tÃªm o mesmo
precedÃªncia do operador, avaliamos da esquerda para a direita da seguinte forma: 12 + 6 * 3% 2 â†’
12 + 18% 2 â†’ 12 + 0 â†’ 12. Vimos que, apesar de todos os operadores do lado direito
lado da expressÃ£o, o resultado Ã© zero, deixando-nos um valor de 12, tornando a opÃ§Ã£o B a
resposta correta.

33. D. O operador XOR ^ avalia como verdadeiro se p e q diferem e falso se eles sÃ£o os
mesmo. Portanto, os valores ausentes sÃ£o verdadeiros e falsos, tornando a opÃ§Ã£o D a correta
responda.

34. C. A chave para entender esta questÃ£o Ã© lembrar que a condiÃ§Ã£o condicional
O operador ConjunÃ§Ã£o && executa apenas o lado direito da expressÃ£o se o lado esquerdo
lado da expressÃ£o Ã© verdadeiro. Se dados sÃ£o uma matriz vazia, a expressÃ£o termina
cedo e nada Ã© produzido. A segunda parte da expressÃ£o retornarÃ¡ true se
o primeiro elemento dos dados Ã© som ou lÃ³gica. Desde que sabemos desde a primeira parte do
Se os dados tiverem pelo menos um comprimento, nenhuma exceÃ§Ã£o serÃ¡ lanÃ§ada. O final
parte da expressÃ£o com data.length <2 nÃ£o altera a saÃ­da quando dados sÃ£o um
matriz de tamanho um. Portanto, som e lÃ³gica sÃ£o duas saÃ­das possÃ­veis. Para estes
motivos, a opÃ§Ã£o C Ã© o Ãºnico resultado inesperado no tempo de execuÃ§Ã£o.

35. C. Na opÃ§Ã£o A, o operador de divisÃ£o / incorretamente vem apÃ³s o decremento â€“â€“
operador. Na opÃ§Ã£o B, o operador de subtraÃ§Ã£o - vem incorretamente apÃ³s o mÃ³dulo
% operador. Na opÃ§Ã£o D, o operador de divisÃ£o / vem incorretamente apÃ³s a subtraÃ§Ã£o
- operador. A resposta correta Ã© a opÃ§Ã£o C, onde todos os trÃªs operadores tÃªm o mesmo
ordem de precedÃªncia.

36. D. O operador exclusivo ou (XOR) ^ exige a avaliaÃ§Ã£o de ambos os operandos para determinar
o resultado. Por esse motivo, as opÃ§Ãµes A e B estÃ£o incorretas. Para a opÃ§Ã£o B, vocÃª nÃ£o pode ter
uma operaÃ§Ã£o de curto-circuito se ambos os operandos forem sempre lidos, portanto ^ ^ nÃ£o existe.
A opÃ§Ã£o C Ã© uma declaraÃ§Ã£o incorreta, pois o operador ^ sÃ³ retorna true se exatamente um
operando Ã© verdadeiro. Por fim, a opÃ§Ã£o D estÃ¡ correta, pois o ^ Ã© aplicado apenas aos valores booleanos
em Java.

37. C. O diagrama representa a sobreposiÃ§Ã£o de x e y, correspondente a quando um deles
Ã© verdade. Portanto, x || y, a opÃ§Ã£o C, corresponde mais a esse relacionamento. Observe que
z nÃ£o Ã© utilizado no diagrama e, portanto, nÃ£o Ã© necessÃ¡rio em nenhuma expressÃ£o.

38. D. O valor de uma instruÃ§Ã£o de caso deve ser constante, um valor literal ou variÃ¡vel final.
Como vermelho estÃ¡ ausente no atributo final, nenhum tipo de variÃ¡vel permite que o cÃ³digo seja compilado,
tornando a opÃ§Ã£o D a resposta correta.

39. C. A questÃ£o Ã© perguntar qual operador representa maior ou igual a e
qual operador Ã© estritamente menor que. O> = e <correspondem a esses operadores,
respectivamente. Portanto, a opÃ§Ã£o C Ã© a resposta correta. Observe que a pergunta nÃ£o
NÃ£o especifique em que ordem os operadores precisariam aparecer, apenas para selecionar os dois
operadores que correspondem Ã  descriÃ§Ã£o da pergunta.

40. B. O cÃ³digo compila e executa sem problemas, tornando as OpÃ§Ãµes C e D incorretas. o
chave aqui Ã© entender a precedÃªncia do operador e aplicar os parÃªnteses para
substituir precedÃªncia corretamente. A primeira expressÃ£o Ã© avaliada da seguinte forma: 10 * (2 +
(3 + 2) / 5) â†’ 10 * (2 + 5/5) â†’ 10 * (2 + 1) â†’ 10 * 3, com um valor final de 30
para tartaruga. Como a tartaruga nÃ£o Ã© menor que 5, um valor de 25 Ã© atribuÃ­do Ã  lebre. Desde a
tartaruga nÃ£o Ã© menos que lebre, a Ãºltima expressÃ£o avalia as vitÃ³rias da tartaruga! , qual Ã©
emitido para o console, tornando a opÃ§Ã£o B a resposta correta.

41. A. Todos os termos de getResult () nesta pergunta sÃ£o avaliados como 0, pois sÃ£o todos menos
igual ou igual a 5. A expressÃ£o pode, portanto, ser reduzida para 0 + 0 + 0 + 0 + "". Desde Java
avalia o operador + da esquerda para a direita, os quatro operandos Ã  esquerda sÃ£o aplicados
usando adiÃ§Ã£o numÃ©rica, resultando na expressÃ£o 0+ "". Esta expressÃ£o apenas converte
o valor para uma String, resultando em uma saÃ­da 0, fazendo da OpÃ§Ã£o A a resposta correta.

42. A. O cÃ³digo Ã© compilado sem problemas, portanto a opÃ§Ã£o D estÃ¡ incorreta. A chave aqui Ã© que o
A instruÃ§Ã£o if-then no mÃ©todo runTest () usa o operador de atribuiÃ§Ã£o (=)
do operador (==). O resultado Ã© que o spinner recebe um valor true e o
A instruÃ§Ã£o (girador = rolo) retorna o valor recÃ©m-atribuÃ­do. O mÃ©todo entÃ£o
retorna, tornando a opÃ§Ã£o A a resposta correta. Se o operador (==) tivesse sido usado em
a instruÃ§Ã£o if-then, o processo teria ramificado para a instruÃ§Ã£o else,
com down sendo retornado pelo mÃ©todo

43. D. DisjunÃ§Ã£o condicional (OR) || operador Ã© verdadeiro se um dos operandos for
true, enquanto o operador complemento lÃ³gico (!) reverte ou vira um valor booleano,
tornando a opÃ§Ã£o D a resposta correta. As outras opÃ§Ãµes usam operadores que nÃ£o
corresponda a esta descriÃ§Ã£o. Em particular, as opÃ§Ãµes A e C incluem operadores que podem apenas
ser aplicado a valores numÃ©ricos, nÃ£o booleanos.

44. A. Embora parÃªnteses sejam recomendados para operaÃ§Ãµes ternÃ¡rias, especialmente
, eles nÃ£o sÃ£o necessÃ¡rios; portanto, a opÃ§Ã£o C estÃ¡ incorreta. A primeira operaÃ§Ã£o ternÃ¡ria
avalia caracteres <= 4 como false, portanto a segunda operaÃ§Ã£o ternÃ¡ria Ã© executada. Desde a
histÃ³ria> 1 Ã© verdadeira, o valor final de movieRating Ã© 2.0, tornando a OpÃ§Ã£o A a correta
resposta.45. B. Exceto quaisquer limitaÃ§Ãµes da JVM, uma instruÃ§Ã£o switch pode ter qualquer nÃºmero de casos
instruÃ§Ãµes (incluindo nenhuma), mas no mÃ¡ximo uma instruÃ§Ã£o padrÃ£o, com a OpÃ§Ã£o B
identificando corretamente esse relacionamento.

46. â€‹â€‹A. O aplicativo usa a conjunÃ§Ã£o condicional && operador para testar se o tempo [0] Ã©
nulo, mas infelizmente esse teste nÃ£o funciona em matrizes de comprimento zero. Portanto, Ã©
possÃ­vel que esse cÃ³digo gere uma ArrayIndexOutOfBoundsException em tempo de execuÃ§Ã£o. o
segunda parte da expressÃ£o Ã© avaliada como verdadeira se a primeira entrada de clima corresponder
ensolarado A parte final da expressÃ£o, &&! False, Ã© uma tautologia, pois Ã© sempre
true e nÃ£o tem impacto na expressÃ£o. Uma exceÃ§Ã£o serÃ¡ lanÃ§ada ou texto
serÃ¡ emitida, com base no valor do tempo, portanto, a opÃ§Ã£o A Ã© a resposta correta.

47. D. A questÃ£o parece muito mais difÃ­cil do que Ã©. De fato, para resolvÃª-lo, vocÃª nÃ£o tem
para calcular qualquer coisa! VocÃª sÃ³ precisa observar que o operador do complemento lÃ³gico (!),
que sÃ³ pode ser aplicado a valores booleanos, estÃ¡ sendo aplicado a um valor numÃ©rico.
Portanto, a resposta Ã© que a expressÃ£o nÃ£o seria compilada ou executada, tornando Option
D a resposta correta.

48. C. A lÃ³gica disjuntiva || O operador avalia como true se um dos operandos for verdadeiro.
Outra maneira de ver isso Ã© que ele sÃ³ avalia falso se ambos os operandos forem falsos.
Portanto, os valores ausentes sÃ£o verdadeiros, tornando a opÃ§Ã£o C a resposta correta.

49. A. Na opÃ§Ã£o B, o operador de subtraÃ§Ã£o - vem incorretamente apÃ³s o decremento â€“â€“
operador. Na opÃ§Ã£o C, o operador de divisÃ£o / vem incorretamente apÃ³s o incremento ++
operador. Na opÃ§Ã£o D, o operador de mÃ³dulo% ocorre incorretamente apÃ³s o incremento
operador ++. A resposta correta Ã© a opÃ§Ã£o A, onde a subtraÃ§Ã£o - e a adiÃ§Ã£o +
operadores sÃ£o seguidos pelos operadores de divisÃ£o / e multiplicaÃ§Ã£o *.

50. C. A chave para resolver este problema Ã© lembrar que o tipo do valor retornado
por uma operaÃ§Ã£o ternÃ¡ria Ã© determinada pelas expressÃµes do lado direito. Em
linha p1, as expressÃµes sÃ£o do tipo int, mas a atribuiÃ§Ã£o Ã© para o jogo variÃ¡vel, de
tipo String. Como a atribuiÃ§Ã£o Ã© invÃ¡lida, o cÃ³digo nÃ£o Ã© compilado e a OpÃ§Ã£o C
estÃ¡ correto.

#Questoes Extras

Pergunta 3: Incorreto

Choose the output of the following program

    class class1 { 
      
        // driver code 
        public static void main(String args[]) 
        { 
            int no1 = 8; 
            int no2 = 4; 
            int res = no1 | no2;
            System.out.println(res);     
        } 
    } 

[A]. 12
B. 0 
C. 8
D. 4  

Se os bits correspondentes de qualquer um dos operandos forem 1, o resultado serÃ¡ 1.
Se os bits correspondentes de ambos os operandos forem 1, tambÃ©m o resultado serÃ¡ 1.
O equivalente binÃ¡rio de 8 Ã© 1000 e 4 Ã© 100, entÃ£o resultado
Ã© 1100 cujo equivalente decimal Ã© 12.




